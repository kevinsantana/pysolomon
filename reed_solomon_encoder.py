from math import ceil
from base64 import b64encode, b64decode

from galois_field import GaloisField
from utils import char_to_int, chunk_message, int_to_char, corrupt_chunk


class RS_Encoder(GaloisField):
    """Reed–Solomon codes are encoded by dividing the polynomial representing
    the message by an irreducible generator polynomial, and then the remainder
    is the RS code, which we will just append to the original message.
    """

    def __init__(self, galois: GaloisField):
        self.galois = galois

    def rs_generator_poly(self, t: int, fcr: int = 0, alpha: int = 2):
        """Generate an irreducible generator polynomial (necessary to encode a
        message into Reed-Solomon).

        Parameters
        ----------
        t: int
            Number of error correcting symbols (degree of the generator polyno-
            mial).

        fcr: int, default=0
            First consecutive root, this allows to specify the value to "jump"
            when computing the sequential terms of the generator polynomial.
            Usually set at 0, but bounded between 0 and the Galois Field's car
            dinality (eg, 255 for GF(2^8)).

        alpha: int, default=2
           Generator number (the "increment" that will be used to walk through
           the field by multiplication, this must be a prime number). This is
           basically the base of the logarithm/anti-log tables. Also often no-
           ted α (alpha) in academic books.

        Returns
        -------
        g: list
            Irreducible generator polynomial.
        """
        g = [1]
        for i in range(t):
            g = super().gf_poly_mul(g, [1, super().gf_pow(alpha, i + fcr)])
        return g

    def rs_generator_poly_all(self, max_t: int, fcr: int = 0, alpha=2):
        """Generate all irreducible generator polynomials up to max_t (usually
        you can use n, the length of the message+ecc). Very useful to reduce pro
        cessing time if you want to encode using variable schemes and k rates.

        Parameters
        ---------
        max_t: int
            n, the length of the message+ecc.

        fcr: int, default=0
            First consecutive root, this allows to specify the value to "jump" when
            computing the sequential terms of the generator polynomial. Usually set
            at 0, but bounded between 0 and the Galois Field's cardinality (eg, 255
            for GF(2^8)).

        alpha: int, default=2
           Generator number (the "increment" that will be used to walk through
           the field by multiplication, this must be a prime number). This is
           basically the base of the logarithm/anti-log tables. Also often no-
           ted α (alpha) in academic books.

        Returns
        -------
        g_all: list
            All irreducible generator polynomials up to max_t.

        """
        g_all = {}
        g_all[0] = g_all[1] = [1]
        for t in range(max_t):
            g_all[t] = self.rs_generator_poly(t, fcr, alpha)
        return g_all

    def correction_capacity(self, n: int, degradation_percentage: int):
        t_candidate = ceil((degradation_percentage/100) * n)
        k = (n-t_candidate)
        t = (n-k) if (n-k) % 2 == 0 else (n-k-1)
        return int(k), int(t)

    def rs_encode_msg(self, msg_in: list, field_order: int, fcr=0, alpha=2,
                      degradation_percentage: int = 15,
                      generator_polynomial=None):
        """Reed-Solomon main encoding function.

        Parameters
        ----------
        msg_in: list
            Input message polynomial, i.e dividend. In base64 format.

        field_order: int
            Order of the field, i.e 2^p.

        degradation_percentage: int

        fcr: int
            First consecutive root, this allows to specify the value to "jump"
            when computing the sequential terms of the generator polynomial.
            Usually set at 0, but bounded between 0 and the Galois Field's car
            dinality (eg, 255 for GF(2^8)).

        alpha: int
            This must be a prime integer, such as 2, 3, 5, etc. In practice,        
            what is the generator? You know, when we use the log/antilog tables
            to do our computations, from what are these tables generated from?
            You guessed it: the generator number. Usually, it's set to 2, so the
            log/antilog tables are generated by computing the sequence of powers:
            0, 2^0, 2^1, ..., 2^p. We can then almost entirely work with these
            log/antilog tables, except at the first stage of encoding, and at
            the first and last stage of decoding, because we need to convert ba
            ck and forth from/to the input numbers to the log/antilog tables va
            lues.

        generator_polynomial
            Irreducible generator polynomial.

        Returns
        -------
        msg_out: list
            msg_out contains the quotient in msg_out[:len(msg_in)] and the rema
            inder in msg_out[len(msg_in):]. Here for RS encoding, we don't need
            the quotient but only the remainder (which represents the RS code),
            so we can just overwrite the quotient with the input message, so that
            we get our complete codeword composed of the message + code.

        Raises
        ------
        """
        n = 255 if field_order == 8 else 65535
        k, t = self.correction_capacity(n, degradation_percentage)
        generator_polynomial = self.rs_generator_poly(t)
        message_int = char_to_int(msg_in)  # base64 to ascii
        chunks = chunk_message(message_int, k)
        redundacy, encoded = list(), list()
        # chunking
        for chunk in chunks:
            if len(chunk) >= k:
                _, remainder = super().gf_poly_div(chunk + [0] * (len(generator_polynomial) - 1), generator_polynomial)
                redundacy.extend(remainder)
            encoded.extend(chunk)
        encoded, redundacy = int_to_char(encoded), int_to_char(redundacy)
        return encoded, redundacy


if __name__ == "__main__":
    gf_285 = GaloisField(0x11d, 8)
    n = 285
    message = b64encode(open("./arquivos_teste/2108_CJF_SUPR.pdf", "rb").read()).decode("UTF-8")
    rs_encoder = RS_Encoder(gf_285)
    encoded, ecc = rs_encoder.rs_encode_msg(message, 8)
    retrived = open("./arquivos_teste/2108_CJF_SUPR_encoded.pdf", "wb").write(b64decode(bytes(encoded, "UTF-8")))
    redundancy = open("./arquivos_teste/2108_CJF_SUPR_redundancy.pdf", "wb").write((bytes(ecc, "UTF-8")))
    print(f"Original: {len(message)}")
    print(f"Encoded: {len(encoded)}")
    print(f"Redundancy: {len(ecc)}")
